1.virtual-dom，dom树深度优先遍历
按dom树结构的层级，深度优先遍历，依次对比vdom节点，属性，子节点，根据对比结果，将更新渲染到dom树上
1）首先，根据dom树深度优先递归遍历，比较vdom节点
2）比较分4种情况：
     1.旧节点不存在，插入新节点；新节点不存在，删除旧节点
     2.新旧节点都存在（排除1则tag相同），先对比新旧节点的属性，再对比新旧子节点的差异（通过key进行重排序，key值相同的节点继续向下遍历）
     3.新旧节点都是VText，判断文本是否发生变化
     4.其他情况，直接用新节点代替旧节点
3）在节点对比中，比较复杂的就是子节点的对比，比如当子节点顺序发生变化时，不应该对所有子     节点进行replace（消耗资源巨大），应当想办法优化
4）更新DOM，将vdom的diff结果（patches）更新到真实的dom上

2.cito.js，基本思路和virtual-dom相同，最大差异在子节点对比上：
1）引入两端对比，将diff算法的速度提升了几个量级
2）移除了patch更新，在diff过程中，直接更新真实dom

3.kivi.js，diff算法在cito的基础上，引入了最长增长子序列，通过子序列找到最小的dom操作数
kivi.js的diff算法：
1）找到数组中首部和尾部公共的节点（公共节点不处理），并在两端移动，遇到非公共节点，尝试     对边比较，即互换位置，当无法操作下去，进行2）算法，可以操作完成至最后，则判断新旧列     表长度是否为0，旧为0，则插入新列表剩余，新为0，则删除旧列表剩余
2）查找需要删除或者插入的节点，并且某个节点是否需要移动
  1》创建新数组P，长度为新子节点列表长度，默认值-1，表示新子节点应该插入的位置
  2》构建对象I，key为新子节点的key，value为新子节点的位置index
  3》遍历旧子节点列表，对照I对象，匹配key，找不到则删除，找到则获取 I对象匹配上的value的       index，并在P上对应index位置插入该旧子节点的位置
  4》判断节点是否需要移动，根据P数组，当存在前一个节点位置大于当前节点位置，则将move设       置为true，表示需要移动
3）检查move标记，为真则查找最小移动数，检查旧子节点长度减去已删除节点的数量等不等于新     子节点的长度，不等，则插入新节点

4.snabbdom
现在主流的虚拟dom方案

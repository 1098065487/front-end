react函数组件和类组件对比分析
1.同于不同
相同点：作为react组件，其作用和效果都是一致的，都是作为react的可复用最小代码片段，返回要渲染的react元素，可以相互转化，也可以混着使用
不同点：设计思想不同，类组件的设计属于面向对象编程，存在内部属性，继承等，函数组件的设计属于函数式编程，与数学中的函数思想相类似，如果假定输入和输出存在某种关联，那么相同的输入必定有相同的输出
对比类组件，函数组件在思想上更加纯粹，简单，更利于测试

一个函数运行时的例子，延时执行，类组件的值会跟随变，函数组件的值仍是上一个运行时的值
（类组件的state是其内部属性，在使用时，永远取得当前最新的state，函数组件永远只有当前运行时，使用的是当前运行时的state）

2.生命周期及仿生命周期实现
类组件通过各种生命周期来包装业务逻辑，挂载-渲染-更新-重渲染-卸载
react 16.8增加hook特性后，函数组件可以依赖hooks仿生命周期来实现业务逻辑，注意，这里的仿生命周期，仅仅是理解上的，实际上，hooks和生命周期并没有关系，函数组件是一个函数，只会从头执行到尾，仅仅是实现了类似生命周期的功能

class组件生命周期使用
按调用顺序来整理：
1.constructor初始化state和绑定函数
2.getDerivedStateFromProps，当props变化来更新state
（存在非受控场景，比如复杂的表单元素，需要自定义，不被form组件直接受控，接受props后赋值给state，props再变化不被识别的情况）
这里每次props传入，都会进入该生命周期，可以缓存上一步props到state，每次对比当前props和上一步props，有变化则更新state，否则不更新，return null）
3.render返回JSX数据结构，描述渲染内容，由react操作jsx完成渲染，render中不能有副作用，否则会死循环
4.componentDidMount，组件挂载完成去做操作，比如网络请求
5.state变化也会触发getDerivedStateFromProps
6.shouldComponentUpdate，判断组件是否重新渲染（官方推荐PureComponent，浅比较state）
7.更新触发render
8.getSnapshotBeforeUpdate和componentDidUpdate，自己在项目中使用的就比较少了
getSnapshotBeforeUpdate在render之前调用，state状态已经更新了，典型的使用场景，可以获取render之前的dom状态，返回值作为componentDidUpate的第三个参数，供其使用
componentDidUpdate可以类似getDerivedStateFromProps 当props变化，更新state，不同的是componentDidUpdate只在更新后调用，初始不调用，且更新state需谨慎（一般添加判断跳出），容易死循环
9.componentWillUnmount，组件卸载时触发，一般清除数据和定时器使用

从上面看，react类组件的生命周期还是很复杂的，一般使用较简单，主要在组件传值，性能优化避免重复渲染上比较复杂

hooks组件仿生命周期实现
类似类组件生命周期，hooks理解上关注类似挂载，渲染，更新，卸载的过程，
使用useState替代类组件state属性
使用useEffect替代生命周期写法
1.函数组件没有render，直接返回JSX数据结构
2.第一次useEffect执行，模拟componentDidMount，useEffect依赖数据，可以监听到变化重新执行useEffect，模拟componentDidUpdate，useEffect return的函数执行，模拟componentWillUnMount

hooks组件实际的执行（非生命周期理解）
effect hook实际是让你在函数组件中执行副作用操作，并没有仿生命周期去设计：
1.使用多个useEffcet，可以实现关注点分离，而不用像生命周期杂糅所有处理逻辑在一起
2.每次更新，都会运行useEffect，当前effcet的运行状态，永远是独立的，减少bug
这里有一个注意点，return每次更新都会执行，并不像类组件卸载才执行，不能理解成类似生命周期，需要判断执行，避免误操作
3.每次更新，都会运行effect，跳过effect进行性能优化，effect依赖可以轻松实现

组件传值和性能优化，更能看出来两种组件的不同

3.组件间传值
class组件传值（父子互传）
1.父传子
1）通过props下传，子组件通过props获取值及方法
2）一般子组件使用后父组件的值，还需要将继续处理的值传回父组件
父组件将值和修改值的方法下传给子组件，子组件接受值为初值，值变化后，子组件调用父组件修改值的方法，将值传回父组件
注意：当子组件接受父组件值使用时，一般会存入子组件的state去使用（只有state变化会引起渲染），此后如果子组件的值不再受父组件控制，即仅接受一次初值，直接在初始化子state时使用props接值即可，如果后续继续接受父组件变化后的值，则需要处理下，一般使用getDerivedStateFromProps生命周期函数去处理，监听上一次props和此次props的变化，有变化则根据props更新state
2.子传父
1）子传父，即父组件调用子组件的属性和方法
原理：父组件提供方法，传递给子组件，在子组件中执行该方法，将子组件的实例绑定到父组件的某个属性下，就可以通过属性绑定的子组件的实例调用子组件的属性和方法了

hook组件传值（父子互传）
1.父传子
基本和类组件一样，通过props下传，子组件使用父组件的属性及方法，子组件继续变化值传回父组件使用。
注意事项：props变化后，子组件不会更新的原理，也和类组件差不多，不同的是，函数组件没有生命周期函数，根据函数运行，直接在函数组件内部判断props变化去更新state
2.子传父，原理思想大致和类组件类似，通过ref绑定子组件要传给父组件的属性和方法的对象，即可在父组件上，通过ref访问到子组件的属性和方法
具体实现：父组件ref传递到子组件，通过useImperativeHandle，在子组件绑定ref和要访问的属性和方法，就可以在父组件，通过ref访问到。
注意：直接用ref传递，ref并不在props中，需要通过React.forwardRef()包装子组件，使子组件获取ref，还有一种写法，定义一个其他属性，比如fuRef，将父组件ref通过props传递到子组件直接使用，就不需要React.forwardRef包装子组件了

4.性能优化相关
关于react类组件和函数组件的性能优化方面，主要体现在组件的不必要渲染的避免上
1.类组件
1）类组件的不必要渲染，官方推荐使用PureComponent对props做一层浅比较避免
2）当props包含引用类型数据时，浅比较已经不满足，需要使用shouldComponentUpdate生命周期函数判断props是否更新决定是否渲染（引用类型的深度比较）

2.函数组件
1）类似PureComponent，可以给函数组件添加一层React.memo()包装，进行比较，判断子组件是否更新，这里只能比较非引用类型，对于函数组件，引用类型永远识别为变化
2）当props包含引用类型数据时，针对函数组件，可以使用useMemo和useCallback分别对属性和方法进行记忆化，当属性和方法未发生变化时，可以识别为未发生变化（这里注意，子组件的React.memo()包装仍需存在）
3）在useMemo和useCallback的依赖中，进行引用类型的变动判断
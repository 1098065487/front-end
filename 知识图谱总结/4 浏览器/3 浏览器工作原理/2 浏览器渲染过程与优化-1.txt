浏览器从url请求到页面展示，主要分为两块内容，即网络进程的网络请求，涉及网络请求，tcp连接，三次握手四次挥手，以及渲染进程的浏览器渲染过程，涉及html解析成dom，css解析成cssom，两者结合生成render tree呈现树或叫渲染树，经过layout布局计算或者叫回流重排，和paint绘制或者叫重绘，渲染出页面并展示到页面

1.JS为什么要是单线程
js诞生之初的使命就是处理页面中的交互，为用户呈现一份动态交互的页面，多线程的话，会带来UI操作上的冲突，如多线程修改同一个Dom节点，会需要浏览器去判断哪个线程生效，为了避免js的复杂性，js在设计之初就被设计成单线程

2.为什么js阻塞页面加载
因为js可操作dom的原因，为防止渲染时UI线程和js线程相互干扰，浏览器设置GUI渲染线程和JavaScript引擎互斥，当JavaScript引擎执行时，GUI线程被挂起，也就是说，当浏览器执行js程序时，GUI渲染线程被保存到队列中，直到js执行完毕才接着执行，当js执行时间过长，就会有页面加载阻塞的感觉

3.css加载会造成阻塞吗？
总结：css加载不会阻塞dom的解析
          css加载会阻塞dom的渲染
          css阻塞其后js的执行
dom由html解析而来，在解析时并不受css加载的限制，但render tree由dom和cssom结合而来，也就是dom渲染受css限制，必须等到css资源加载完成才能开始渲染，js是可操作dom和css的，故而GUI渲染和js引擎互斥，css后的js会等待css加载完毕才执行

4.DOMContentLoaded与load的区别
事件发生的时序不同，DOMContentLoaded会在load事件之前发生
DOMContentLoaded事件的发生时序：
DOMContentLoaded表示dom解析完成时事件触发，会有两种情况：
1）文档无脚本，浏览器解析完dom直接触发事件
2）文档有脚本，脚本阻塞文档解析，脚本受css限制，需等css加载完执行
两种情况都不需要要等待图片及其他资源加载完成，解析出dom即可事件触发

load事件触发，则需要页面所有资源加载完毕，最终触发

5.什么是关键渲染路径（CRP）？如何优化？
关键渲染路径是浏览器将html, css, javascript转换成屏幕呈现内容所经历的一系列步骤，也就是浏览器渲染流程
为尽快完成首次渲染，需要最大限度减小一下三种可变因素：
1>关键资源数量：可能阻止网页首次渲染的资源
2>关键路径长度：获取所有关键资源所需的往返次数或总时间
3>关键字节：实现网页首次渲染所需总字节数，等同于所有资源传送文件大小的总和

1）优化dom:
1>删除不必要的代码和注释包括空格，尽量做到最小化文件
2>可以利用Gzip压缩文件
3>结合http缓存文件

2）优化cssom
1>缩小、压缩和缓存对css同样重要，由于css阻止页面呈现，可以这方面优化（以下两条）
2>减少关键css元素数量
3>css中关注媒体查询的类型，媒体查询极大的影响CRP的性能

3）优化javascript
浏览器遇到js，会阻止解析，直到cssom构建完毕，js才执行，并继续解析dom
1>async：script标签添加async，解析过程不被阻止，即不会阻止CRP
2>defer：与async区别在于，脚本等到文档解析后执行（DOMContentLoaded事件前），而async允许脚本在文档解析时位于后台运行
3>脚本不修改dom和cssom时，推荐使用async
4>预加载：preload & prefetch
5>DNS预解析：dns-prefetch

总结：
1>分析并用关键资源数，关键字节数，关键路径长度来描述CRP
2>最小化关键资源数：消除他们（内联），推迟他们下载（defer），使他们异步解析（async）
3>优化关键字节数（缩小，压缩）来减少下载时间
4>优化加载剩余关键资源的顺序：让关键资源（css）尽早下载以减少CRP长度
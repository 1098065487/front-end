ES6以前，只有全局作用域和函数作用域，可能带来不合理场景：
1）变量提升，不期待的内层变量定义会覆盖外层变量
2）用来计数的变量泄露为全局变量（for循环）

ES6引入let实际上为js新增了块级作用域

所谓块级作用域，指的就是变量仅在当前代码块有效不同层级或同层不同区域的代码块中，同名变量互不干扰

引入块级作用域，使得在块级作用域声明函数有了特殊，在es5中，可以在块级作用域中声明函数，在支持es6的浏览器中，却会报错，由于环境导致行为差异太大，应该避免在块级作用域中声明函数，正确的使用方法，应该通过函数表达式的方式来声明函数



有一个大胆的想法：
es6引入块级作用域后，执行上下文其实就和es5不太一样了，块级作用域打破了作用域链，变量不存在提升和向上查找的问题，仅在当前作用域定义使用（错误理解）
还是有层级关系和作用域链的，因为即使时块级作用域，只要不重复定义同名参数，仅仅是使用外层的参数，实际还是存在作用域链的，还是会向上查找，更多的是不在变量提升，如果重名定义会报错，使用在定义前也会报错（变量不提升，但是存在暂时性死区）
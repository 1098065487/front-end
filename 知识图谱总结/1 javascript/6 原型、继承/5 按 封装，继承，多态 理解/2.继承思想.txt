无论是es6之前的借助构造函数和原型链的继承，还是es6的class和extends，其实思想都一样，class实际就是基于构造函数和原型链的语法糖

js的继承，实际应该考虑的是构造和构造之间的继承，具体表现会在构造实例化出的对象上体现出来

针对构造之间的继承，一般考虑两个部分：
1）构造上实例属性和方法的继承
2）构造原型链（函数也是对象）上的属性和方法的继承

针对1），实例属性和方法的继承，一般借助于构造函数，保证属性在不同实例上的特异性，特别是引用类型属性，互不干扰
针对2），构造原型链上的属性和方法的继承，仍是借助于原型链实现，流程是：将子类型的原型对象指向一个根据父类型原型对象创建出的纯净空对象，一般是Object.create()创建，再将子类型的原型对象中的constructor属性指向改回为子类构造：
Child.prototype = Object.create(Parent.prototype)；
Child.prototype.construcor = Child;

在实际理解js继承的过程中，曾经理解为继承分为属性和方法两部分，属性用构造实现，方法借助原型链实现，这种理解并不正确，但是有一定正确理由，因为在定义构造函数时，一般会将属性直接定义在构造函数内，保证不同实例获取特异的属性，互不干扰，对于方法一般会提取到上层原型对象中，因为方法一般会让实例共用，达到复用效果，所以放在上层原型链上，这样看，就和上面的原理部分相符了，但实际，方法不一定都是在原型链上的，所以理解不正确，比如在es6 class中，用constructor或者用 = 定义的，都是在实例上的属性和方法，这里的方法就是在实例上

1.原理：在子类构造中，使用call或apply调用父类构造，让子类型实例获取父类型属性和方法
function Child() { 
    Parent.call(this, ...arguments)  或者  Parent.apply(this, [...arguments])
}

2.优点：(解决了原型链继承的缺点）
构造继承是在子类构造中，通过子类实例的this，调用到父类的构造，因此每次实例化，都是一般的构造实例一样，互相独立，解决了原型链继承的缺点，同时也带来新的缺点（没有继承父类原型对象）
1）避免父类引用类型属性被所有实例共享
2）可以在在子类中，向父类构造传参

3.缺点：
直接利用父类构造去继承父类属性和方法，这样做没有继承到父类的原型对象，且父类的引用数据类型和方法，在子类继承时是构造创建的，每个实例都会创建一次，浪费资源
1）没有继承父类的原型对象，也就不能获取父类原型对象上及更上层(不与子类共有)的属性和方法
2）构造继承，每个实例都会去创建父类的引用类型属性和方法，造成资源浪费
3）实例并不是父类的实例，只是子类的实例
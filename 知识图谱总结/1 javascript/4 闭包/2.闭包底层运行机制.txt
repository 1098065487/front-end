var myClosure = (function outer() {
  var hidden = 1;
  return {
    inc: function inner() { return hidden++; }
  }
}());
myClosure.inc();  // 1
myClosure.inc();  // 2
myClosure.inc();  // 3

闭包的实现基础是：利用了作用域链

JavaScript运行时，需要预先存储本地变量便于执行时使用，这个存储空间叫做作用域对象（或者叫变量对象）

作用域对象是保存在js的堆内存的，所以在函数返回闭包内部函数后，内部函数的作用域对象不被销毁，还能被访问到

作用域对象可以有父级作用域对象，当代码访问一个变量时，会先在当前作用域对象中查找，若不存在，会继续去父级作用域对象中查找，直到有结果，这个过程链路就叫做作用域链

作用域链和原型链很类似，但是原型链找不到属性，返回undefined，作用域链找不到属性，抛出一个错误ReferenceError


闭包的原理：
当函数嵌套，外部函数返回内部函数，并且内部函数使用外部函数的作用域对象时，如果这个嵌套函数执行的结果赋值给某个变量引用时，则内部函数及其作用域链上的作用域对象不会被垃圾回收

考虑一种特殊情况，当外层嵌套的函数是带参数的，这里不同的参数调用之间不会相互干扰，因为参数也是外部函数作用域对象的一部分，不同参数不同作用域对象，不同的作用域意味着不同的作用域链，而不同的作用域链之间是互相不干扰的，这样可以写一个工具函数

this和作用域链之间没有关系，this值的指向，取决于函数被调用是的情景


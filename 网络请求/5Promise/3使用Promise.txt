1.链式调用
promise的链式调用本质其实是回调，但是在回调中，返回的仍是promise，从而可以形成链路

我的理解，和回调写法不同，多层回调嵌套，会有回调地狱的问题，但是对promise的处理，可以把错误处理的回调提取出来到同一个catch()方法中，这样形式上直链逻辑下去，解决了回调地狱的问题

形式上直链，往往让异步的代码看上去就像处理同步一样，在es8新特性中，添加的async/await语法糖，更是让这种同步形式处理异步得到极致表现

2.一些常用方法
Promise.resolve()和Promise.reject()，在创建Promise时，手动创建这两个函数的调用

Promise.all()和Promise.race()，通常这两个方法用在并行运行的异步操作上
插一句：前端并行异步请求，一般通过Promise.all()处理，参数就是多个并行请求的操作，都会返回              promise的处理结果
             只有全部正确，才会触发外层Promise的正确处理，且外层正确处理函数获取的参数，是全             部参数promise正确返回的结果
             当存在一个参数promise结果是失败，则会被外层catch()方法获取，参数就是这个失败的             原因
这里使用可能会有小缺陷，当页面整体并行去获取页面数据时，当一个发生失败，其他正确的也都获取不到了，而页面会啥数据都拿不到

3.时序问题
简单理解下Promise的时序问题
第一层，所有语句按顺序执行，遇到promise，由于状态未知，不执行内层逻辑
第二层，当外层事件队列执行完，开始进入promise内层，当遇到then()或catch()，由于返回的仍是	             一个promise，状态未知，不执行
第三层，按照顺序和嵌套，往复执行前两步，形成时序
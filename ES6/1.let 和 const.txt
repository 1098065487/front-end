1.let：用来声明变量
  与var相比优点：
1）所声明的变量仅在let所在代码块内有效
2）与var不同，不存在变量提升
3）存在暂时性死区：
   es6规定，区块中存在let或const命令的，区块将对这些命令声明的变量形成  封闭作用域，在声明之前的调用，都会报错，不管在区块外层（甚至父级作用域）有同名变量的声明。
   简单一句话：区块内使用let或const声明的变量，只在声明后使用。
4）不允许在相同作用域内重复声明一个变量

es6规定let和const不存在变量提升，以及暂时性死区，主要就是为了规范代码，防止在变量声明前就调用变量，减少可能的错误

2.es6引入块级作用域：
1）块级作用域直接将状态的管理限定在代码块中，互不干扰，更不易出错。
2）函数声明在es6里时允许出现在块级作用域的，行为类似于let，但是实际上为了兼容es5，浏览器在这样做时，行为仍类似于var，所以一般还是不建议在块级作用域内进行函数声明，即使要写，也是写成函数表达式的形式。

3.const：用来声明一个只读常量
1）行为基本和let一致，块级作用域有效，不存在变量提升，存在暂时性死区，不允许重复声明，还有一点，由于是声明常量，声明时必须赋值。
2）声明基本数据类型时，相当于常量值不变，声明引用数据类型的值时，实质是内存地址值不变，里层的结构是可以变化的，比如数组和对象。

4.es6针对顶层对象的属性，跟全局变量做了脱钩
顶层对象，在浏览器环境指window对象，在node环境指global对象。
在es5环境下，顶层对象的属性和全局变量是等价的，可以互相访问，这种情况其实是奇怪的
es6开始脱钩，var和function保持兼容，声明的全局变量仍是顶层对象的属性，但let，const，class声明的全局变量，不再属于顶层对象的属性

5.关于顶层对象的新提案：
js中关于顶层对象的实现，跟环境有关：
浏览器里面，顶层对象是window
浏览器和Web Worker里面，self也指向顶层对象
node里面，顶层对象是global

ES2020引入globalThis作为顶层对象，任何环境下，都可以通过globalThis拿到顶层对象，指向全局环境下的this

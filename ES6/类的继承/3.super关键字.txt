1.super作为函数调用：
super()代表父类构造，所以在子类的constructor方法中，必须在第一行调用super();
尽管super指向父类的构造，但是返回的是子类的实例，super()内部this指向子类的实例，实际上子类constructor中的 super(); 相当于 Parent.prototype.constructor.call(this)

2.super作为对象使用：
super用作对象时，在普通方法中，指向父类的原型对象，在静态方法中，指向父类。
1）指向父类的原型对象，意味着super调用的必须是类原型上的属性和方法，定义在父类this上的（     类的实例上）方法和属性，不能在子类被super调用
2）普通方法中使用super调用父类方法时，方法是父类的，方法的主体（方法内部this）却是子类的     this（实例），所以子类的super调用才会反应在子类的实例上
3）在静态方法中super调用，此时super指向父类，这个也比较好理解，就像静态方法是由类直接调     用，在子类中调用父类静态，super指向也应该是类才对，所以指向父类
4）同样的，静态方法中，super调用指向父类，方法是父类的静态方法，但方法的主体（方法内部     this）却是子类，所以子类调用结果才是子类特有的